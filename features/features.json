[
  {
    "id": "3b866a1d-8de9-4999-bbf3-651c1eb6ec5e",
    "name": "Unsafe Evaluation Functions",
    "description": "# Unsafe Evaluation Functions\n\nThe use of unsafe evaluation functions like eval(), exec(), and similar constructs that dynamically execute code based on user input creates significant RCE risks. These are often found in calculator functions, mathematical operations, and dynamic code generation features in AI systems.\n\nExamples:\n\n- Evaluation Function Vulnerabilities in Python\n\nVulnerabilities related to Python's eval(), exec(), and similar functions that execute string-based code dynamically. These functions are particularly dangerous when processing untrusted input from LLMs or external sources without proper sanitization.\n- Template Insertion Command Injection\n\nVulnerabilities where user-controlled input is inserted into command templates or strings that are later executed by the system. This includes cases where parameters are passed to system commands or where template strings are constructed with insufficient validation.\n- LLM-Generated Code Execution\n\nVulnerabilities arising from executing code generated by LLMs without proper sandboxing or validation. This includes cases where AI-generated code is trusted and executed in contexts with access to sensitive system resources.\n- Insufficient Input Sanitization\n\nVulnerabilities resulting from inadequate validation and sanitization of user inputs or LLM outputs before processing by evaluation functions. This includes bypass techniques for existing validation mechanisms and instances where validation is entirely absent.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://unsafe_dynamic_code_execution",
        "name": "unsafe_dynamic_code_execution",
        "description": "This resource identifies code locations that use functions for dynamic code evaluation (e.g., Python's eval(), exec()) or system command execution (e.g., os.system(), subprocess.run() with shell=True). It specifically targets cases where the executed code or command string is not a hardcoded literal but is dynamically constructed or originates from external sources like user input, LLM-generated content, or network data, indicating potential Remote Code Execution (RCE) risks.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "The code snippet contains a function call that dynamically executes code or system commands. Examples include Python's `eval()`, `exec()`, or functions like `os.system()`, `subprocess.run()` (especially with `shell=True`), `subprocess.call()` (with `shell=True`), or `popen()`. The critical feature is that the string representing the code or command to be executed is not a hardcoded literal; instead, it's derived from a variable, function argument, string concatenation/formatting, or an external source such as user input, network request, or LLM output.",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "b2565e7b-dacc-44e5-9817-a31898326bc1",
    "name": "Pickle/Cloudpickle Deserialization",
    "description": "# Pickle/Cloudpickle Deserialization\n\nPython's pickle and cloudpickle libraries are commonly used in AI frameworks for serializing objects but are inherently unsafe when deserializing untrusted data. These vulnerabilities occur in distributed training, RPC mechanisms, and model loading functions. Without proper validation, these can be exploited to execute arbitrary code during deserialization.\n\nExamples:\n\n- Network Communication and RPC Vulnerabilities\n\nVulnerabilities in distributed systems where pickle/cloudpickle deserialization is used for network communication and remote procedure calls, allowing attackers to execute arbitrary code across network boundaries.\n- Model Loading and Data Processing Vulnerabilities\n\nVulnerabilities in AI systems where deserialization of untrusted model files or datasets can lead to remote code execution when loading pretrained models or processing external data files.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://pickle_cloudpickle_deserialization_snippets",
        "name": "pickle_cloudpickle_deserialization_snippets",
        "description": "This resource flags all code snippets that perform deserialization of data using Python's `pickle` or `cloudpickle` libraries (e.g., `pickle.load()`, `pickle.loads()`, `cloudpickle.load()`, `cloudpickle.loads()`). Deserializing data from untrusted sources with these libraries is a significant security risk, potentially leading to arbitrary code execution. This configuration specifically targets instances where the input to these deserialization functions is not a hardcoded literal, indicating that the data might originate from an external or dynamic source.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "This code snippet deserializes data using functions from Python's `pickle` or `cloudpickle` libraries, such as `load()` or `loads()`. The input data for the deserialization operation is not a hardcoded literal.",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "a8a337fc-4a32-4bf9-b98c-4b30a666352a",
    "name": "Magic Bytes File Type Manipulation",
    "description": "# Magic Bytes File Type Manipulation\n\nAttackers can bypass file validation checks by manipulating file headers or 'magic bytes' to disguise malicious code as legitimate file types. For example, prepending 'GIF87a' to PHP code can trick the system into identifying the file as a GIF image while still allowing the code to execute when accessed through the web server.\n\nExamples:\n\n- Magic Bytes File Type Manipulation\n\nMagic Bytes File Type Manipulation is a technique used to bypass file upload restrictions by modifying the first few bytes of a file to mimic a different file type. This technique can lead to Remote Code Execution (RCE) vulnerabilities when malicious server-side code disguised as harmless file types is uploaded and executed on the server. In the context of AI infrastructure security, this technique poses significant risks as it can bypass security controls and enable attackers to gain unauthorized access to execution environments.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://file_type_validation_by_magic_bytes",
        "name": "file_type_validation_by_magic_bytes",
        "description": "This resource identifies code locations where file type validation is performed by inspecting the initial bytes (magic bytes, file signature, or header) of a file. Such checks are often found in file upload handlers or file processing routines and can be a target for Magic Bytes File Type Manipulation if not implemented securely, allowing attackers to disguise malicious files as legitimate types.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "This code snippet implements logic to determine or validate a file's type by reading and analyzing its initial bytes (e.g., magic bytes, file signature, or header). This is often part of a file upload handling mechanism or file processing pipeline where verifying the actual content type based on its leading bytes is critical.",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "9011537d-3f3a-4587-9500-068c453194f9",
    "name": "Shell Command Execution",
    "description": "# Shell Command Execution\n\nShell command execution vulnerabilities occur when applications directly pass user-controlled input to shell commands without proper validation. These vulnerabilities can be exploited through manipulating parameters, function arguments, or system calls to inject malicious commands that execute with the privileges of the application process.\n\nExamples:\n\n- Insecure Command Execution in Shell Commands\n\nShell command execution vulnerabilities occur when user-controlled input is directly incorporated into system commands without proper sanitization. These vulnerabilities typically involve functions that execute shell commands with user input, allowing attackers to inject additional commands that can be executed on the host system. The impact ranges from unauthorized access to complete system compromise.\n- Unsafe Evaluation of Dynamic Code\n\nVulnerabilities arising from the unsafe evaluation of dynamic code, particularly through functions like eval() or similar mechanisms that interpret strings as code. This allows attackers to execute arbitrary code when user input is directly passed to such functions without proper validation or sanitization, often bypassing intended security controls.\n- Improper File Path or Name Validation\n\nVulnerabilities resulting from insufficient validation or sanitization of file paths or names that are used in command execution contexts. Attackers can craft special filenames or paths containing shell metacharacters to achieve command injection, particularly when these values are incorporated into shell commands.\n- API Endpoint Control Weaknesses\n\nVulnerabilities in API endpoints that fail to properly authenticate or validate incoming requests, allowing attackers to inject malicious commands through specially crafted requests. These issues often appear in web services or remote interfaces that execute commands based on user input without sufficient validation.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://command_injection_and_unsafe_eval_snippets",
        "name": "command_injection_and_unsafe_eval_snippets",
        "description": "This resource flags code locations that execute shell commands, external programs, or evaluate dynamic code using non-literal inputs. These are potential sinks for command injection or arbitrary code execution if external input influences the command or code being executed. This covers direct command execution (e.g., using functions like os.system, subprocess.run with shell=True, Runtime.exec) and dynamic code evaluation (e.g., using functions like eval, exec, ScriptEngine.eval()), where the executed content is not a hardcoded literal.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "This code snippet executes a shell command, system command, an external program, or evaluates a string as code. This is often done using functions like `os.system`, `subprocess.call`, `subprocess.run` (especially with `shell=True`), `subprocess.Popen` (especially with `shell=True`), `commands.getoutput`, `Runtime.getRuntime().exec`, `ProcessBuilder`, `php.system`, `php.exec`, `php.shell_exec`, `php.passthru`, `php.popen`, PHP backticks (` `), `Node.child_process.exec`, `Node.child_process.execSync`, `eval`, `exec`, `ScriptEngine.eval()`, `execCommand`, `Perl.system`, `Ruby.system`, `Ruby.exec`, Ruby backticks (``), `Go.os/exec.Command`, etc. The command string, arguments to the command, or the string being evaluated as code, are derived from variables, function parameters, or other dynamic sources, rather than being solely hardcoded string literals.",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "ab624bd9-92e7-4f34-a2b4-02a914a78040",
    "name": "Command Injection in CLI Applications",
    "description": "# Command Injection in CLI Applications\n\nMachine learning frameworks and tools that expose CLI functionality may be vulnerable to command injection if they fail to properly validate or sanitize user inputs before passing them to system shells. This is particularly concerning in ML pipelines where commands are dynamically constructed based on user-provided parameters.\n\nExamples:\n\n- CLI Command Injection Vulnerabilities\n\nCommand injection vulnerabilities in CLI applications occur when user-supplied input is improperly validated before being passed to command execution functions. These vulnerabilities allow attackers to execute arbitrary OS commands by inserting malicious content into CLI arguments. The impact can range from unauthorized system access to privilege escalation.\n- Input Parameter Exploitation in CLI Tools\n\nCLI applications often accept various input parameters that can be manipulated by attackers. This includes both direct command arguments and data file imports that may contain malicious formulas or commands. Tools that process CSV files or execute dynamic code based on user input are particularly vulnerable to this type of attack.\n- Attack Impact and Consequences\n\nThe exploitation of command injection vulnerabilities in CLI applications can lead to significant security breaches. Attackers can gain unauthorized system access, execute arbitrary code, exfiltrate sensitive data, and potentially use these vulnerabilities as stepping stones for privilege escalation attacks. In some cases, these attacks can even affect user systems when processing exported data from vulnerable applications.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://potential_command_injection",
        "name": "potential_command_injection",
        "description": "This resource flags code locations that execute operating system commands where the command string is dynamically constructed. Such dynamic construction, if influenced by external inputs (like CLI arguments, configuration, or data files) without proper sanitization, can lead to command injection vulnerabilities in CLI applications. These locations are primary candidates for further investigation.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "This code snippet executes operating system commands using functions like `os.system`, `subprocess.run`, `subprocess.Popen`, `subprocess.call`, `subprocess.check_output`, `commands.getoutput`, or `pty.spawn`. The command being executed is dynamically constructed using string operations (e.g., concatenation, f-strings, `.format()`) with variables that could hold data from external sources like command-line arguments or file content. Prioritize instances where `subprocess` functions are used with `shell=True` or where command components are assembled from non-literal string variables.",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "1f7cc885-ad42-42a7-a051-0bb5cd97374f",
    "name": "Other Deserialization Mechanisms",
    "description": "# Other Deserialization Mechanisms\n\nBeyond pickle, other deserialization mechanisms like dill, shelve, and JDBC can lead to RCE when improperly implemented. These are often exploited in model loading, session management, and database connections.\n\nExamples:\n\n- Model File Deserialization Vulnerabilities\n\nVulnerabilities arising from unsafe loading of model files in AI infrastructure, which can lead to remote code execution. This includes issues with PyTorch's torch.load() and similar mechanisms that execute arbitrary code during deserialization.\n- Python Shelve Module Deserialization\n\nVulnerabilities stemming from the use of Python's shelve module for data persistence, which can lead to RCE when deserializing malicious payloads. This affects framework components like Kedro's ShelveStore that use shelve for session management.\n- JDBC Deserialization Vulnerabilities\n\nVulnerabilities in AI systems that support database connectivity through JDBC drivers, where malicious JDBC URLs can trigger deserialization attacks. This affects systems like h2o-3 that support database connections for data import operations.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://other_deserialization_code_snippets",
        "name": "other_deserialization_code_snippets",
        "description": "This resource flags code snippets performing deserialization using specific mechanisms like PyTorch's `torch.load`, Python's `shelve` module, or JDBC connections. It focuses on cases where the input data (e.g., model file, shelved data, JDBC URL components) is not a hardcoded literal and could originate from an untrusted source, which are potential indicators of Remote Code Execution (RCE) vulnerabilities.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "This code snippet performs deserialization of data using PyTorch's `torch.load()` (or similar model loading functions in AI/ML frameworks), Python's `shelve` module (e.g., `shelve.open()`, `shelf[key]`), or JDBC connection mechanisms (e.g., constructing connection URLs or using drivers). The deserialization is flagged if the input data (such as a model file path or content, data from a shelve file, or components of a JDBC URL) is not a hardcoded literal and could originate from an untrusted external source.",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "dbfd2d19-9e1a-4c1a-b1f1-79318deebb06",
    "name": "Path Traversal and File Operations",
    "description": "# Path Traversal and File Operations\n\nPath traversal vulnerabilities in file operations allow attackers to manipulate file paths to access arbitrary files outside intended directories. When combined with command execution capabilities, these can lead to RCE by overwriting executable files, configuration files, or accessing sensitive system files that can be leveraged for further attacks.\n\nExamples:\n\n- Unsanitized File Path Handling\n\nVulnerabilities arising from insufficient sanitization of user-supplied file paths, allowing attackers to manipulate paths to access or write files outside of intended directories. These occur when applications fail to properly validate, normalize, or sanitize file paths before using them in file operations.\n- Improper Archive Extraction\n\nVulnerabilities resulting from unsafe extraction of archive files (tar, zip, etc.) that contain malicious entries with path traversal sequences. When applications extract these archives without proper validation, attackers can place files in arbitrary locations on the filesystem.\n- Local File Inclusion (LFI)\n\nVulnerabilities allowing attackers to include files on a server through the web browser by manipulating file-related variables. In AI systems, this often occurs when applications include or process files based on user-supplied paths without proper validation.\n- Bypass of Existing Path Sanitization\n\nVulnerabilities where attackers bypass implemented path sanitization methods using alternative path representations, encoding tricks, or exploiting flaws in the sanitization logic itself.\n- Insecure File Upload Implementation\n\nVulnerabilities in file upload functionality that fail to properly restrict the destination path or file name, allowing attackers to upload files to arbitrary locations on the server.\n- Command Injection via File Operations\n\nVulnerabilities where file paths or names are passed unsanitized to system commands, allowing command injection attacks through specially crafted filenames containing shell metacharacters.\n- Deserialization and Code Execution Vectors\n\nVulnerabilities where path traversal is combined with insecure deserialization or code execution mechanisms, allowing attackers to execute arbitrary code after gaining write access to specific locations.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://potential_path_traversal_sources",
        "name": "potential_path_traversal_sources",
        "description": "This resource identifies code snippets potentially vulnerable to path traversal. It flags locations where: \n1. File system operations are performed (e.g., open, read, write, delete, move, copy, list, archive extraction, file inclusion).\nOR\n2. File paths/names are used in system commands.\nAND\n3. The file paths or filenames are constructed from or influenced by external inputs (e.g., user-provided data, network requests, configuration settings, function arguments traceable to external sources).\nAND\n4. There's an indication or possibility that these paths are not robustly sanitized against path traversal manipulations (like '..', absolute paths, symlinks, special characters, encoding tricks).\nThese snippets are entry points for investigating potential path traversal vulnerabilities.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "Locate code snippets that perform file system operations (such as reading, writing, deleting, moving files or directories, extracting archives, or including files) or use file paths or names within system commands. Focus on cases where these file paths or names are derived from, or can be influenced by, external sources (e.g., user input, network data, API parameters, environment variables, or function arguments traceable to such sources) and where there is a potential lack of, or insufficient, sanitization or validation against path traversal techniques (e.g., sequences like '..', absolute paths, symbolic links, null bytes, or encoding tricks).",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "bd1ec518-2837-40a2-ab2d-fc38099b3686",
    "name": "Arbitrary File Write",
    "description": "# Arbitrary File Write\n\nVulnerabilities that allow writing arbitrary files to the system can lead to RCE by overwriting critical files or creating new executable files in accessible locations. These vulnerabilities often arise from improper path validation, directory traversal flaws, or insufficient permission checks.\n\nExamples:\n\n- Path Traversal-Based File Overwrite Vulnerabilities\n\nA significant attack vector in AI infrastructure involves exploiting path traversal vulnerabilities that allow attackers to write arbitrary files to unauthorized locations. This typically occurs when user-controlled parameters containing path components are not properly sanitized, allowing navigation outside intended directories. Such vulnerabilities are particularly dangerous as they enable overwriting of critical system files, leading to remote code execution.\n- API Endpoint File Upload Vulnerabilities\n\nAI systems often expose API endpoints for model and data management that can be exploited to upload or write arbitrary files. These vulnerabilities occur when the API lacks proper authorization controls or input validation. Attackers can leverage these endpoints to upload malicious files to sensitive locations, particularly targeting configuration files that execute on system events or login.\n- Dataset Source Loading Vulnerabilities\n\nAI systems that load datasets from external sources can be vulnerable to arbitrary file write attacks. When dataset loading mechanisms don't properly validate destination paths or content, attackers can manipulate the system into writing controlled content to arbitrary locations. This is especially concerning when the framework automatically fetches datasets from user-specified URLs without proper security controls.\n- Metadata File Manipulation Vulnerabilities\n\nAI frameworks store model metadata in configuration files that, if improperly secured, can be manipulated to achieve arbitrary file writes. Attackers can exploit weaknesses in metadata handling to create or overwrite files in unauthorized locations. This is particularly problematic in ML platforms that allow users to define metadata formats or paths without sufficient validation.\n- Post-Exploitation Attack Techniques\n\nOnce arbitrary file write capabilities are established, attackers employ several techniques to achieve remote code execution. Common approaches include overwriting SSH authorized_keys files to gain persistent access, manipulating shell configuration files like .bashrc to execute malicious commands on login, creating web shells for remote access, and compromising application configuration files to trigger code execution when the application loads.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://potential_arbitrary_file_write",
        "name": "potential_arbitrary_file_write",
        "description": "This resource identifies code snippets that perform file system write operations (e.g., creating, writing to, moving, or copying files using functions like `open`, `shutil.copy`, `shutil.move`, `os.rename`, `Path.write_text`, framework-specific file saving methods, archive extraction like `zipfile.extractall` or `tarfile.extractall` without path sanitization). The key characteristic is that the destination path, filename, or the content being written appears to be derived from or influenced by external sources (like user input, API parameters, network data, or configuration values). These locations are flagged because they might lack robust sanitization, validation, or proper permission checks, potentially leading to arbitrary file write vulnerabilities such as path traversal or overwriting critical files.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "This code snippet involves a file system write operation (such as creating, writing to, or moving a file). The destination path, filename, or the content of the file appears to be constructed or influenced by data originating from an external source (e.g., user input, API request parameters, network data, configuration files, environment variables) and there is no clear evidence of robust sanitization, validation, or restriction of the path to a predefined safe directory.",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  },
  {
    "id": "50794dd5-45fd-43e4-afd3-37359ef5b076",
    "name": "Bypass of File Extension Restrictions",
    "description": "# Bypass of File Extension Restrictions\n\nThis vulnerability occurs when systems implement incomplete file extension blacklists or fail to properly validate file types, allowing attackers to bypass security controls by uploading files with unusual but executable extensions (like .phps, .hphp) that can be processed by the server. Apache and other web servers may be configured to execute these non-standard file types, leading to remote code execution.\n\nExamples:\n\n- PHP-Based Extension Bypass Techniques\n\nVarious techniques to bypass file extension restrictions in web applications that specifically target PHP execution. These bypasses allow attackers to upload and execute malicious code despite implemented restrictions on common PHP extensions.\n- Alternative PHP Extension Exploitation\n\nMethods that exploit lesser-known or uncommon PHP file extensions that may not be included in blacklists. This includes using extensions like .phps and .hphp that might still be executed by the server despite restrictions on standard extensions.\n- Magic Bytes Bypass Technique\n\nThe use of magic bytes (file signatures) to disguise malicious files as legitimate file types. For example, prepending 'GIF87a' to PHP code to make the file appear as a GIF image while maintaining executable PHP code within.\n",
    "resources": [
      {
        "type": "ToolCallingResource",
        "uri": "project://file_upload_processing_and_validation",
        "name": "file_upload_processing_and_validation",
        "description": "This resource identifies code segments involved in processing uploaded files. This includes retrieving file metadata (like name and extension), determining storage paths, saving files to the server, and any explicit validation logic based on file extensions (e.g., checking against blacklists/whitelists), MIME types, or content signatures (magic bytes). These locations are primary areas to investigate for 'Bypass of File Extension Restrictions' vulnerabilities, as weaknesses in validation (e.g., incomplete blacklists missing extensions like .phtml, .phar, .phps, .hphp), improper handling of file names/extensions, or flawed type detection can lead to security bypasses allowing unauthorized code execution if the server is configured to process such files.",
        "content": "",
        "repo_url": "",
        "tool_name": "SemanticCodeFilterTool",
        "tool_input_kwargs": {
          "filter_prompt": "This code snippet is involved in processing files uploaded by users. This includes operations such as retrieving the original filename or file extension, determining the destination path or filename for storage, moving or saving the uploaded file to the server's filesystem, and/or implementing validation rules to restrict allowed file types. These validation rules might be based on the file's extension (e.g., checking against a list of permitted or forbidden extensions like '.php', '.jsp', '.asp', '.exe', '.gif', '.jpg'), its MIME type, or its initial bytes (magic bytes/file signatures).",
          "subdirs_or_files": [
            "/"
          ]
        },
        "class_name": "ToolCallingResource"
      }
    ],
    "extra": {},
    "class_name": "Feature"
  }
]